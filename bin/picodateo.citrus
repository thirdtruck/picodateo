grammar PicoDateo
  rule game
    (scene*) {
      Game.new(matches.map { |m| [m.value.name, m.value] }.to_h)
    }
  end

  rule commands
    (speech | speech newline | if_cond | jump | stage_direction | choice | set)+
  end

  rule scene
    ('scene(' scene_name:(chars) '):' newline commands space 'end' newline) {
      scene_name = capture(:scene_name).value.to_sym
      c = capture(:commands).matches.map { |m| m.value }
      Scene.new(scene_name, c)
    }
  end

  rule choice
    (space 'choice:' space newline options:(option*) space 'end' newline) {
      options = capture(:options).matches.map { |m| m.value }
      Choice.new(options || [])
    }
  end

  rule option
    (space 'option(' scene_name:(chars) '):' space speech_text newline space 'end' newline) {
      Option.new(capture(:speech_text), capture(:scene_name))
    }
  end

  rule speech_text
    [^\n]*
  end

  rule narrator
    ('[]') {
      # TODO: Figure out why we can't seem to return a symbol from here, instead of capturing '[]'
    }
  end

  rule actor_name
    (name:(chars+)) {
      capture(:name)
    }
  end

  rule stage_direction
    (space '[' actor_name ':' instructions ']' space newline) {
      StageDirection.new(capture(:actor_name), capture(:instructions))
    }
  end

  rule instructions
    chars*
  end

  rule speech
    (space speaker:('[' actor_name ']'|narrator) space speech_text space newline) {
      narrator = capture(:narrator)
      if (narrator)
        speaker = :_narrator
      else
        speaker = capture(:actor_name)
      end

      Speech.new(speaker, capture(:speech_text).value.strip)
    }
  end

  rule variable_name
    chars (chars | [0-9])*
  end

  rule set
    (space 'set(' variable_name '=' new_value:([0-9]+) ')' space newline) {
      Assignment.new(capture(:variable_name), capture(:new_value).value.to_i)
    }
  end

  rule if_cond
    (space 'if(x)' space newline commands space 'end' space newline) {
      IfCond.new('wip', capture(:commands).matches.map { |m| m.value })
    }
  end

  rule jump
    (space 'jump(' scene_name ')' space newline) {
      SceneJump.new(capture(:scene_name))
    }
  end

  rule scene_name
    chars
  end
    
  rule chars
    [a-zA-Z_]+
  end

  rule space
    [ \t]*
  end

  rule newline
    [\n\r]+
  end
end
